
# 第四章: 提升

到现在为止，你应该已经很熟悉作用域的概念，以及根据声明的位置和方式将变量分配给
作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在
某个作用域内的变量，都将附属于这个作用域。

但是作用域同其中的变量声明出现的位置有某种微妙的联系，而这个细节正是我们将要讨
论的内容。

## 先有鸡还是先有蛋?

直觉上会认为JavaScript 代码在执行时是由上到下一行一行执行的。但实际上这并不完全
正确，有一种特殊情况会导致这个假设是错误的。



```js
a = 2;

var a;

console.log( a );
```

你认为console.log(..) 声明会输出什么呢？

很多开发者会认为是undefined，因为var a 声明在a = 2 之后，他们自然而然地认为变量
被重新赋值了，因此会被赋予默认值undefined。但是，真正的输出结果是2。



```js
console.log( a );

var a = 2;
```

鉴于上一个代码片段所表现出来的某种非自上而下的行为特点，你可能会认为这个代码片
段也会有同样的行为而输出2。还有人可能会认为，由于变量a 在使用前没有先进行声明，
因此会抛出ReferenceError 异常。

不幸的是两种猜测都是不对的。输出来的会是undefined。

那么到底发生了什么？看起来我们面对的是一个先有鸡还是先有蛋的问题。到底是声明
（蛋）在前，还是赋值（鸡）在前？

## 编译器解析过程

当你看到var a = 2; 时，可能会认为这是一个声明。但JavaScript 实际上会将其看成两个
声明：var a; 和a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在
原地等待执行阶段。

我们的第一个代码片段会以如下形式进行处理：

```js
var a;
```
```js
a = 2;

console.log( a );
```

其中第一部分是编译，而第二部分是执行。

类似地，我们的第二个代码片段实际是按照以下流程处理的：

```js
var a;
```
```js
console.log( a );

a = 2;
```

这个过程就好像变量和函数提前了，这个过程就叫作提升

换句话说，先有蛋（声明）后有鸡（赋值）。

只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变
了代码执行的顺序，会造成非常严重的破坏。

```js
foo();

function foo() {
	console.log( a ); // undefined

	var a = 2;
}
```

foo 函数的声明（这个例子还包括实际函数的隐含值）被提升了，因此第一行中的调用可
以正常执行。

另外值得注意的是，每个作用域都会进行提升操作。尽管前面大部分的代码片段已经简化
了（因为它们只包含全局作用域），而我们正在讨论的foo(..) 函数自身也会在内部对var
a 进行提升（显然并不是提升到了整个程序的最上方）。因此这段代码实际上会被理解为下
面的形式：

```js
function foo() {
	var a;

	console.log( a ); // undefined

	a = 2;
}

foo();
```

可以看到，函数声明会被提升，但是函数表达式却不会被提升。

```js
foo(); // 不是ReferenceError, 而是TypeError!

var foo = function bar() {
	// ...
};
```

这段程序中的变量标识符foo() 被提升并分配给所在作用域（在这里是全局作用域），因此
foo() 不会导致ReferenceError。但是foo 此时并没有赋值（如果它是一个函数声明而不
是函数表达式，那么就会赋值）。foo() 由于对undefined 值进行函数调用而导致非法操作，
因此抛出TypeError 异常。

同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。

```js
foo(); // TypeError
bar(); // ReferenceError

var foo = function bar() {
	// ...
};
```

这个代码片段经过提升后，实际上会被理解为以下形式：

```js
var foo;

foo(); // TypeError
bar(); // ReferenceError

foo = function() {
	var bar = ...self...
	// ...
}
```

## 函数优先

函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个
“重复”声明的代码中）是函数会首先被提升，然后才是变量。


```js
foo(); // 1

var foo;

function foo() {
	console.log( 1 );
}

foo = function() {
	console.log( 2 );
};
```

会输出1 而不是2 ！这个代码片段会被引擎理解为如下形式：

```js
function foo() {
	console.log( 1 );
}

foo(); // 1

foo = function() {
	console.log( 2 );
};
```

注意，var foo 尽管出现在function foo()... 的声明之前，但它是重复的声明（因此被忽
略了），因为函数声明会被提升到普通变量之前。

尽管重复的var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。

```js
foo(); // 3

function foo() {
	console.log( 1 );
}

var foo = function() {
	console.log( 2 );
};

function foo() {
	console.log( 3 );
}
```

虽然这些听起来都是些无用的学院理论，但是它说明了在同一个作用域中进行重复定义是
非常糟糕的，而且经常会导致各种奇怪的问题。

一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代
码暗示的那样可以被条件判断所控制：

```js
foo(); // "b"

var a = true;
if (a) {
   function foo() { console.log( "a" ); }
}
else {
   function foo() { console.log( "b" ); }
}
```

但是需要注意这个行为并不可靠，在JavaScript 未来的版本中有可能发生改变，因此应该
尽可能避免在块内部声明函数。

## 总结

我们习惯将var a = 2; 看作一个声明，而实际上JavaScript 引擎并不这么认为。它将var a
和a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。

这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。
可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的
最顶端，这个过程被称为提升。

声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。

要注意避免重复声明，特别是当普通的var 声明和函数声明混合在一起的时候，否则会引
起很多危险的问题！